# 性能优化



## 网络相关

#### 使用 HTTP / 2.0
在 HTTP / 1.1 时代，每个请求都需要建立和断开，消耗了好几个 RTT （客户到服务器往返所花时间，round-trip time）时间，并且由于 TCP 慢启动的原因，加载体积大的文件会需要更多的时间。

在 HTTP / 2.0 中引入了多路复用，能够让多个请求使用同一个 TCP 链接，极大的加快了网页的加载速度。并且还支持 Header 压缩，进一步的减少了请求的数据大小。

##### Prefetch提前加载：

在浏览器空闲的时候提前加载资源并缓存。如果某个资源的preFetch还没有完成页面就要使用，这个时候会再次发送请求。因此**不要在当前页面中的资源使用prefetch**
    
```<link href="main.js" rel="prefetch">```

##### 预渲染
可以通过预渲染将下载的文件预先在后台渲染

```<link rel="prerender" href="http://example.com" />```

##### DNS 预解析
X-DNS-Prefetch-Control: on/ off

X-DNS-Prefetch-Control 头控制着浏览器的 DNS 预读取功能。 DNS 预读取是一项使浏览器主动去执行域名解析的功能，其范围包括文档的所有链接，包括图片的，CSS 的，还是 JavaScript 等其他用户能够点击的 URL。因为预读取会在后台执行，所以 DNS 很可能在链接对应的东西出现之前就已经解析完毕。这能够减少用户点击链接时的延迟。

DNS 请求需要的带宽非常小，但是延迟却有点高，这点在手机网络上特别明显。预读取 DNS 能让延迟明显减少一些，例如用户点击链接时。在某些情况下，延迟能减少一秒钟。 
<b>在某些浏览器中这个预读取的行为将会与页面实际内容并行发生（而不是串行）。</b>正因如此，某些高延迟的域名的解析过程才不会卡住资源的加载。

##### 打开关闭方式：

1. 在服务器端发送 X-DNS-Prefetch-Control 报头，或是在文档中使用值为 http-equiv 的 <meta> 标签：

       <link rel="dns-prefetch" href="http://www.spreadfirefox.com/">
2. 通过使用 rel 属性值为 link type 中的 dns-prefetch 的 <link> 标签来对特定域名进行预读取：

        <link rel="dns-prefetch" href="http://www.spreadfirefox.com/">

默认情况下，通过 HTTPS 加载的页面上内嵌链接的域名并不会执行预加载。在 Firefox 浏览器中，可以通过设置 network.dns.disablePrefetchFromHTTPS 值为 false 来改变这一默认行为。

浏览器对网站第一次的域名DNS解析查找流程依次为：
浏览器缓存-系统缓存-路由器缓存-ISP DNS缓存-递归搜索（图一）

##### 特性
Chrome会记住最近使用的10个domain，并且在开启浏览器时自动解析，因此在打开这些常用页面的时候，并不会有DNS Lookup的延迟情况。

chrome使用8个线程专门做DNS Prefetching，而且chrome本身不做dns记录的cache，是直接从操作系统读dns。所以直接修改系统的dns记录或者host是可以直接影响chrome。

浏览器会对a标签的href自动启用DNS Prefetching，所以a标签里包含的域名不需要在head中手动设置link。但是在HTTPS下面不起作用，需要meta来强制开启功能。这个限制的原因是防止窃听者根据DNS Prefetching推断显示在HTTPS页面中超链接的主机名。

DNS解析的包很小，一个UDP的包小于100 bytes，却平均可节省200ms。

本地缓存DNS数量有限，可暂存50-200个domain，Chrome会决定该删除哪些domain的缓存，常用的网站会被标记为“最近使用”，不会那么快被删除。而如google.com、yahoo.com等大型网站过期时间大概在5分钟左右，可以更好的适应服务变化。

##### 场景


页面中的静态资源在不同的domain下，如CSS、JS、图片等文件

适合在以下场景中使用：

电商网站的商品页大量载入不同domain下的商品图，如淘宝
手机网页
大型网站
js或服务端重定向

参考文章：https://www.xuanfengge.com/dns-prefetching-analysis.html

------------------------------------------------------------------------------
#### 缓存
##### Pragma  （HTTP/1.0）

Pragma 是HTTP/1.0标准中定义的一个header属性，请求中包含Pragma的效果跟在头信息中定义Cache-Control: no-cache相同，但是HTTP的响应头不支持这个属性，所以它不能拿来完全替代HTTP/1.1中定义的Cache-control头。通常定义Pragma以向后兼容基于HTTP/1.0的客户端。
```
<meta http-equiv="Pragma" content="no-cache">
```
注意：
1. 仅有IE才能识别这段meta标签含义，其它主流浏览器
        仅能识别“Cache-Control: no-store”的meta标签```<meta http-equiv="Cache-Control" content="no-cache">```。
2. **在IE中识别到该meta标签含义，并不一定会在请求字段加上Pragma**，但的确会让当前页面每次都发新请求（仅限页面，页面上的资源则不受影响）。

##### Expires  （HTTP/1.0）
Expires的值对应一个GMT（格林尼治时间），比如“Mon, 22 Jul 2002 11:12:01 GMT”来告诉浏览器资源缓存过期时间，如果还没过该时间点则不发请求。
在客户端我们同样可以使用meta标签来告诉IE（仅有IE能识别）页面（同样也只对页面有效，对页面上的资源无效）缓存时间：```<meta http-equiv="expires" content="mon, 18 apr 2016 14:30:00 GMT">```

如果希望在IE下页面不走缓存，发新请求，那么可以把“content”里的值写为“-1”或“0”：```<meta http-equiv="expires" content="-1">```。
注意的是**该方式仅仅作为IE缓存时间的标记，你并不能在请求或响应报文中找到Expires字段。**

**Pragma的优先级高于Expirse**：如果Pragma禁用缓存，又给Expires定义一个还未到期的时间，刷新页面时发现均发起了新请求，这意味着Pragma字段的优先级会更高。

##### Cache-Control  （HTTP/1.1）

Cache-Control:no-store|no-cache|max-age| s-maxage

    no-store 禁止缓存对响应复制。
    
    no-cache 可以存储在本地，只是在与原始服务器进行新鲜度再验证之前，缓存不能将其提供给客服端响应首部。
    
    max-age 表示从服务器将文档传来之时起，可以认为此文档处于新鲜状态的秒数。
    
    s-maxage：与max-age 相似，只是它只适合公有缓存。 


http1.1新增了 Cache-Control来定义缓存过期时间，**Cache-Control优先级高于Expirse，Pragma**。

组合的形式还能做一些浏览器行为不一致的兼容处理。例如在IE我们可以使用 no-cache 来防止点击“后退”按钮时页面资源从缓存加载，但在 Firefox 中，需要使用 no-store 才能防止历史回退时浏览器不从缓存中去读取数据，故我们在响应报头加上如下组合值即可做兼容处理：**Cache-Control: no-cache, no-store（保证在所有浏览器中历史回退时浏览器不从缓存中去读取数据）**



#### 协商缓存
如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304。

##### Last-Modified 和 If-Modified-Since
---> If-Modified-Since 

<--- Last-Modified

Last-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。

但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag 。

##### ETag 和 If-None-Match
---> If-None-Match 

<--- ETag          

ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 **ETag 优先级比 Last-Modified 高**。

------------------------------------------------------------------------------
##### 懒执行

该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒。

##### 懒加载

对于图片来说，先设置图片标签的 src 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 src 属性，这样图片就会去下载资源，实现了图片懒加载。

---
## 文件优化

#### 图片优化
##### 压缩图片大小
一张 100*100 像素的图片，图像上有 10000 个像素点，如果每个像素的值是 RGBA 存储的话，那么也就每个像素有 4 个通道，每个通道 1 个字节（8 位 = 1 个字节），所以该图片大小大概为 39KB（10000 _ 1 * 4 / 1024）。

但是在实际项目中，一张图片可能并不需要使用那么多颜色去显示，我们可以通过减少每个像素的调色板来相应缩小图片的大小。

优化图片思路：

1. 减少像素点
2. 减少每个像素点能够显示的颜色

##### 图片加载优化

1. 尽量用 CSS 代替图片。
2. 将图片存放在 CDN 上。
3. 移动端根据适配宽度请求相应裁剪好的照片
4. 小图片转base64，放在代码中(如果转换的代码过多也会导致文件臃肿)。
5. 能用SVG 代替的图片用SVG。
6. 尽量使用 WebP 格式。WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积
7. 将多个图标文件整合到一张图片中（雪碧图）

##### 其他文件优化
1. CSS 文件放在 head 中
2. 服务端开启文件压缩功能
3. 
- 将 script 标签放在 body 底部，因为 JS 文件执行会阻塞渲染；

- 添加 defer ，表示该文件会并行下载，但是会放到 HTML 解析完成后顺序执行。
        
- 对于没有任何依赖的 JS 文件可以加上 async ，表示加载和渲染后续文档元素的过程将和 JS 文件的加载与执行并行无序进行。
4. 费时的代码可以考虑使用 Webworker。Webworker 可以让我们另开一个线程执行脚本而不影响渲染。

##### CDN
静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie。

#### 其他
##### 使用 Webpack 优化项目
对于 Webpack4，打包项目使用 production 模式，这样会自动开启代码压缩
使用 ES6 模块来开启 tree shaking，这个技术可以移除没有使用的代码
优化图片，对于小图可以使用 base64 的方式写入文件中
按照路由拆分代码，实现按需加载
给打包出来的文件名添加哈希，实现浏览器缓存文件
##### 监控
使用 window.onerror 拦截报错。该方法能拦截到大部分的详细报错信息，但是可能也有例外

- 对于跨域的代码运行错误会显示 Script error. 对于这种情况我们需要给 script 标签添加 crossorigin 属性
- 对于某些浏览器可能不会显示调用栈信息，这种情况可以通过 arguments.callee.caller 来做栈递归

对于异步代码来说，可以使用 catch 的方式捕获错误。比如 Promise 可以直接使用 catch 函数，async await 可以使用 try catch

线上运行的代码都是压缩过的，需要在打包时生成 sourceMap 文件便于 debug。

对于捕获的错误需要上传给服务器，通常可以通过 img 标签的 src 发起一个请求。

## 代码相关

1. 在实现动画的时候使用 translate 替代 top。

<div class="test"></div>
<style>
  .test {
    position: absolute;
    top: 10px;
    width: 100px;
    height: 100px;
    background: red;
  }
</style>
<script>
  setTimeout(() => {
    // 引起回流
    document.querySelector('.test').style.top = '100px'
  }, 1000)
</script>

2. 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）

3. CSS 选择符从右往左匹配查找，避免 DOM 深度过深

4. 一下复杂的动画可以使用GUP加速。

5. 把 DOM 离线后修改，将所有的DOM修改完成后再添加到文档中。比如：先把 DOM 给 display:none (有一次 Reflow)，然后你修改 100 次，然后再把它显示出来

6. 不要把 DOM 结点的属性值放在一个循环里当成循环里的变量

```
for (let i = 0; i < 1000; i++) {
  // 获取 offsetTop 会导致回流，因为需要去获取正确的值
  console.log(document.querySelector('.test').style.offsetTop)
}
```

7. 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局

8. 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame




## 面试题
如何渲染几万条数据并不卡住界面





