# 性能优化



## 网络相关

#### 使用 HTTP / 2.0
在 HTTP / 1.1 时代，每个请求都需要建立和断开，消耗了好几个 RTT （客户到服务器往返所花时间，round-trip time）时间，并且由于 TCP 慢启动的原因，加载体积大的文件会需要更多的时间。

在 HTTP / 2.0 中引入了多路复用，能够让多个请求使用同一个 TCP 链接，极大的加快了网页的加载速度。并且还支持 Header 压缩，进一步的减少了请求的数据大小。

##### Prefetch提前加载：

在浏览器空闲的时候提前加载资源并缓存。如果某个资源的preFetch还没有完成页面就要使用，这个时候会再次发送请求。因此**不要在当前页面中的资源使用prefetch**
    
```<link href="main.js" rel="prefetch">```

##### 预渲染
可以通过预渲染将下载的文件预先在后台渲染

```<link rel="prerender" href="http://example.com" />```

##### DNS 预解析
X-DNS-Prefetch-Control: on/ off

X-DNS-Prefetch-Control 头控制着浏览器的 DNS 预读取功能。 DNS 预读取是一项使浏览器主动去执行域名解析的功能，其范围包括文档的所有链接，包括图片的，CSS 的，还是 JavaScript 等其他用户能够点击的 URL。因为预读取会在后台执行，所以 DNS 很可能在链接对应的东西出现之前就已经解析完毕。这能够减少用户点击链接时的延迟。

DNS 请求需要的带宽非常小，但是延迟却有点高，这点在手机网络上特别明显。预读取 DNS 能让延迟明显减少一些，例如用户点击链接时。在某些情况下，延迟能减少一秒钟。 
<b>在某些浏览器中这个预读取的行为将会与页面实际内容并行发生（而不是串行）。</b>正因如此，某些高延迟的域名的解析过程才不会卡住资源的加载。

##### 打开关闭方式：

1. 在服务器端发送 X-DNS-Prefetch-Control 报头，或是在文档中使用值为 http-equiv 的 <meta> 标签：

       <link rel="dns-prefetch" href="http://www.spreadfirefox.com/">
2. 通过使用 rel 属性值为 link type 中的 dns-prefetch 的 <link> 标签来对特定域名进行预读取：

        <link rel="dns-prefetch" href="http://www.spreadfirefox.com/">

默认情况下，通过 HTTPS 加载的页面上内嵌链接的域名并不会执行预加载。在 Firefox 浏览器中，可以通过设置 network.dns.disablePrefetchFromHTTPS 值为 false 来改变这一默认行为。

浏览器对网站第一次的域名DNS解析查找流程依次为：
浏览器缓存-系统缓存-路由器缓存-ISP DNS缓存-递归搜索（图一）

##### 特性
Chrome会记住最近使用的10个domain，并且在开启浏览器时自动解析，因此在打开这些常用页面的时候，并不会有DNS Lookup的延迟情况。

chrome使用8个线程专门做DNS Prefetching，而且chrome本身不做dns记录的cache，是直接从操作系统读dns。所以直接修改系统的dns记录或者host是可以直接影响chrome。

浏览器会对a标签的href自动启用DNS Prefetching，所以a标签里包含的域名不需要在head中手动设置link。但是在HTTPS下面不起作用，需要meta来强制开启功能。这个限制的原因是防止窃听者根据DNS Prefetching推断显示在HTTPS页面中超链接的主机名。

DNS解析的包很小，一个UDP的包小于100 bytes，却平均可节省200ms。

本地缓存DNS数量有限，可暂存50-200个domain，Chrome会决定该删除哪些domain的缓存，常用的网站会被标记为“最近使用”，不会那么快被删除。而如google.com、yahoo.com等大型网站过期时间大概在5分钟左右，可以更好的适应服务变化。

##### 场景


页面中的静态资源在不同的domain下，如CSS、JS、图片等文件

适合在以下场景中使用：

电商网站的商品页大量载入不同domain下的商品图，如淘宝
手机网页
大型网站
js或服务端重定向

参考文章：https://www.xuanfengge.com/dns-prefetching-analysis.html

------------------------------------------------------------------------------
#### 缓存
##### Pragma  （HTTP/1.0）

Pragma 是HTTP/1.0标准中定义的一个header属性，请求中包含Pragma的效果跟在头信息中定义Cache-Control: no-cache相同，但是HTTP的响应头不支持这个属性，所以它不能拿来完全替代HTTP/1.1中定义的Cache-control头。通常定义Pragma以向后兼容基于HTTP/1.0的客户端。
```
<meta http-equiv="Pragma" content="no-cache">
```
注意：
1. 仅有IE才能识别这段meta标签含义，其它主流浏览器
        仅能识别“Cache-Control: no-store”的meta标签```<meta http-equiv="Cache-Control" content="no-cache">```。
2. **在IE中识别到该meta标签含义，并不一定会在请求字段加上Pragma**，但的确会让当前页面每次都发新请求（仅限页面，页面上的资源则不受影响）。

##### Expires  （HTTP/1.0）
Expires的值对应一个GMT（格林尼治时间），比如“Mon, 22 Jul 2002 11:12:01 GMT”来告诉浏览器资源缓存过期时间，如果还没过该时间点则不发请求。
在客户端我们同样可以使用meta标签来告诉IE（仅有IE能识别）页面（同样也只对页面有效，对页面上的资源无效）缓存时间：```<meta http-equiv="expires" content="mon, 18 apr 2016 14:30:00 GMT">```

如果希望在IE下页面不走缓存，发新请求，那么可以把“content”里的值写为“-1”或“0”：```<meta http-equiv="expires" content="-1">```。
注意的是**该方式仅仅作为IE缓存时间的标记，你并不能在请求或响应报文中找到Expires字段。**

**Pragma的优先级高于Expirse**：如果Pragma禁用缓存，又给Expires定义一个还未到期的时间，刷新页面时发现均发起了新请求，这意味着Pragma字段的优先级会更高。

##### Cache-Control  （HTTP/1.1）

Cache-Control:no-store|no-cache|max-age| s-maxage

    no-store 禁止缓存对响应复制。
    
    no-cache 可以存储在本地，只是在与原始服务器进行新鲜度再验证之前，缓存不能将其提供给客服端响应首部。
    
    max-age 表示从服务器将文档传来之时起，可以认为此文档处于新鲜状态的秒数。
    
    s-maxage：与max-age 相似，只是它只适合公有缓存。 


http1.1新增了 Cache-Control来定义缓存过期时间，**Cache-Control优先级高于Expirse，Pragma**。

组合的形式还能做一些浏览器行为不一致的兼容处理。例如在IE我们可以使用 no-cache 来防止点击“后退”按钮时页面资源从缓存加载，但在 Firefox 中，需要使用 no-store 才能防止历史回退时浏览器不从缓存中去读取数据，故我们在响应报头加上如下组合值即可做兼容处理：**Cache-Control: no-cache, no-store（保证在所有浏览器中历史回退时浏览器不从缓存中去读取数据）**



#### 协商缓存
如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304。

##### Last-Modified 和 If-Modified-Since
---> If-Modified-Since 

<--- Last-Modified

Last-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。

但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag 。

##### ETag 和 If-None-Match
---> If-None-Match 

<--- ETag          

ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 **ETag 优先级比 Last-Modified 高**。

------------------------------------------------------------------------------
##### 懒执行

该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒。

##### 懒加载

对于图片来说，先设置图片标签的 src 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 src 属性，这样图片就会去下载资源，实现了图片懒加载。

---
## 文件优化

#### 









































































