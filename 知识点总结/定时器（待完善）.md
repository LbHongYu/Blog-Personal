#### 定时器
setTimeout 和 setInterval 都属于异步API, 这篇文章不会讲JavaScript的异步模型。主要讲关于setTimeout，setInterval 中，
回调函数执行时机和设定时间，主线程任务执行时间的关系。

setInterval 的第二个参数是一个毫秒数指的就是第一个参数（回调）每隔多长时间执行。 setTimeout 的第二个参数（毫秒数）是指第一个参数（回调），多久时间之后执行。

我们一起探讨关于setInterval，setTimeout 的回调执行时机。

> #### setInterval
##### setInterval 的执行间隔时间
setInterval 指定的是 “开始执行” 之间的间隔，并不考虑每次任务执行本身所消耗的时间。
因此，两次执行之间的间隔（指定时间-执行时间）会小于指定的时间。如果回调函数执行时间大于设置时间，回调执行一完成就马上进入下一个回调的执行，这样后面逐渐有越来越多的回调累加。
比如，setInterval指定每 100ms 执行一次，每次执行需要 5ms，那么第一次执行结束后95毫秒，第二次执行就会开始。如果某次执行耗时特别长，比如需要105毫秒，那么它结束后，下一次执行就会立即开始。然后会有越来越多的任务堆积在事件队列中。

* 执行间隔时间 = 指定时间-执行时间
```
function sleep(ms) {
  var start = Date.now();
  while ((Date.now() - start) < ms) {
  }
}
```
```
setInterval(function(){
	console.count(); 
	sleep(1000)
	console.log("finish waiting"); 

}, 2000);	
// 由于在回调中，执行 sleep 耗时了1000 ms，所以打印了"finish waiting"之后，会在 1000ms 就会打印console.count 的计数。
```
* 执行时间 > 指定时间
```
setInterval(function(){
	console.count(); 
	sleep(2001)
	console.log("finish waiting"); 

}, 2000);	
// 从第一个计时器开始，打印了	"finish waiting" 就会马上进入下一个执行,打印 console.count() 的计数，
```


为了确保两次执行之间有固定的间隔，可以使用 setTimeout 代替 setInterval。
```
function _setInterval(fn, ms){
	var timer = setTimeout(function f() {
	  fn();
	  if(timer)clearTimeout(timer)
	  timer = setTimeout(f, ms);
	}, ms);	 
}
```

##### setInterval 的开始执行时间

setInterval 的开始执行时间：设置时间 - 同步任务执行时间。
等到本轮事件循环的所有同步任务都执行完，才会开始执行。 如果同步任务执行时间大于setInterval设置时间，setInterval 的回调会等待同步任务的执行结束，且暂停计时。此时，即使同步任务时间很长， setInterval也不会开始计时，回调函数也不会执行。等同步任务执行结束，恢复计时，马上执行回调。 后来就会按正常执行，（设置时间 - 回调函数执行时间） 后执行回调。

* 开始执行时间 = 设置时间 - 同步任务执行时间
```
setInterval(function () {
	console.timeEnd("interval");
  console.count(); 
}, 3000);

sleep(2000);
console.time("interval");

//同步任务 sleep 中耗时2000ms。 所以第一个回调会在 1000ms 之后就会运行。
```
* 设置时间 < 同步任务执行时间
```
console.log("start");
setInterval(function () {
  console.count(); 
}, 2000);

sleep(4000);
console.log("weka")
//生效后setInterval不会产生累积效应，即不会一下子输出两个 console.count 的计数，而是只会输出一个。	

```

> #### setTimeout
setTimeout 指的超时执行，所以我们只用讨论它的“开始执行时间”。 setTimeout 的执行时机和 setInterval 的类似， 如果开始执行时间 = 设定时间 - 同步任务的时间。 如果同步任务的时间大于设定时间，就在同步任务执行完之后马上执行回调。

* 开始执行时间 = 设置时间 - 同步任务执行时间
```
console.log("start");
setTimeout(function(){
	console.timeEnd("Timeout")	
}, 3000);

sleep(1000);
console.log("over");
console.time("Timeout");
// 同步任务中的 sleep 耗时3000ms, setTimeout 的设定时间为1000ms， 所以在2000ms左右， 回调就会被执行。
```
* 设置时间 < 同步任务执行时间
```
console.log("start");
setTimeout(function(){
	console.timeEnd("Timeout")	
}, 1000);

sleep(3000);
console.log("over");
console.time("Timeout");
// 同步任务中的 sleep 耗时3000ms, 大于seTimeout 设定的时间，所以同步任务一结束，setTimeout 的回调就马上执行了。
```

> #### setTimeout(f, x)

setTimeout(fn, x) 表示延迟x毫秒之后执行fn。，但是一般并不能保证立刻就执行f，要看主线程的Js 执行情况，延迟的时间严格来说总是大于设置的毫秒。

setTimeout(fn, 0) 表示主线程代码执行完成之后就 0 延时执行 fn。
HTML5 规范规定最小延迟时间不能小于4ms，即如果小于4，会被当做4来处理。 不过不同浏览器的实现不一样，比如，Chrome可以设置1ms，IE11/Edge是4ms。

