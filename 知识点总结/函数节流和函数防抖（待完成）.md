#### 防抖：
1. 多次触发执行一次
```
function debounce1(fn, wait){
	  var timer = null;
    return function(){
	    var args = arguments,
	    		context =  this;
			
			if(timer)clearTimeout(timer);
	    timer = setTimeout(function(){
				fn.apply(context, args);
				timer = null;
	    }, wait)
        
    }
}

```
2. 多次触发执行第一次和最后一次
```
function debounce2(fn, wait, immedate){
	var callNow = false, timer = null;
	return function(){
		var args = arguments,
				context = this;
		
		if(timer)clearTimeout(timer);
		bCallNow = !timer;
		if(bCallNow)fn.apply(context, args);
		timer = setTimeout(function(){	
			timer	= null;
			fn.apply(context, args);
		},wait)
	}
}
```

两者结合：

```
function debounce3(fn, wait, immedate = false){
	var bCallNow = false, timer = null;

	return function(){
		var args = arguments,
				context = this;
		
		if(timer)clearTimeout(timer);

		if(immedate){				
			bCallNow = !timer;
			if(bCallNow)fn.apply(context, args);
			timer = setTimeout(function(){									
				fn.apply(context, args);
			},wait)
		}else{
			timer = setTimeout(function(){
				fn.apply(context, args)
			},wait)
		}
	}
}
```

3. 上面实现 ```多次触发执行第一次和最后一次``` 的方法中有一个小瑕疵，当用户第二次触发的时候， 第一次的触发函数不会执行。
因为timer的是一个真值，那我们可以让timer在最后一次执行后将 timer 的值设置为falsely值。

```
function debounce3(fn, wait, immedate = false){
	var bCallNow = false, timer = null;

	return function(){
		var args = arguments,
				context = this;
		
		if(timer)clearTimeout(timer);

		if(immedate){				
			bCallNow = !timer;
			if(bCallNow)fn.apply(context, args);
			timer = setTimeout(function(){	
				//确保下一次触发的时候立马执行
				timer = null;

				fn.apply(context, args);
			},wait)
		}else{
			timer = setTimeout(function(){
				fn.apply(context, args)
			},wait)
		}
	}
}
```


#### 节流

function throttle(fn, delay, must){
	var start = Date.now(),
			timer = null;

	return function(){
		var context = this,
				args = arguments,
				now = Date.now();
		
		if(timer)clearTimeout(timer);

		if(now - start >= must){
			fn.apply(context, args);
			start = Date.now();
		}else{
			timer = setTimeout(function(){
				fn.apply(context, args);
				start = Date.now();
				timer = null
			},delay)
		}


	}
}