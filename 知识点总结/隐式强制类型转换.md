
### 隐式强制类型转换

在我们学习JavaScript 的隐式强制类型转换之前我们先看看两端段代码：
```
var obj = {
    valueOf:() => 1
}
console.log(true == obj); //??
```

```
var arr = [1,2];
arr.valueOf = () => "valueOf";
arr.toString = () => "toString";
console.log(arr + 1);   //??
console.log(arr + "a"); //??
```

这两端代码里面会的console.log 方法会打印出来什么东西呢？ 如果你看到这段代码是一头雾水， 说明你对隐式强制类型转换规则不是很清楚，可能也没有听说过这个名字，但我相信你肯定在你的代码运用到了。
那我们接下来一起看看这个隐式强制类型转换到底是什么东西。如果你对隐式强制类型转换已经掌握了，那也跟着一起来温习一边，我相信读完这篇文章你会有新的体会。


#### 转换为布尔值

下面的情况会发生布尔值隐式强制类型转换。

1. if (..) 语句中的条件判断表达式。
2. for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。
3. while (..) 和do..while(..) 循环中的条件判断表达式。
4. ? : 中的条件判断表达式。

```
var opt1 = "opt1", opt2 = 2;
if(opt1||opt2){
    console.log("get opt !");
}
```
    
在 ```opt1||opt2``` 我们得到的是"opt1", 然而```if(...)``` 需要判断一个布尔值。这时候就发生了转布尔值的隐式强制类型转换，如果要想避免这种转换我们可以使用 ```!!``` 在之前就把所有的操作数转为布尔值。因为 ```!``` 的优先级要高于判断运算符，所以会先执行取反运算。

```!!opt1||!!opt2``` 等于 ```true||true```

&& 和 || 运算符的返回值并不一定是布尔类型，而是两个操作数其中一个的值。

&&: 如果运算结果为真， 那个返回最后一个操作数；如果运算结果为假，返回第一个为假的操作数。

||： 如果为运算结果为真，返回第一个为真的操作数，如果为假，返回最后一个操作数。

```
2 && 3 && 4;     //4
"a" && 0 && "b"; //0
2 || 3 || 0;     //2 
false || 0 || ""; //""
```

用途：

1. 设置参数的默认值， a || "default value"。
2. 取对象的值， obj && obj.val。
3. 预判条件： val && foo()


#### 对象转换为原始值：
        
1. 转换为布尔值：所有的对象转换为布尔值时都为true

2. 转换为字符串和转换为数字时，有两种转换方法toString()和valueOf()，在不同的场景会使用不同的方法。


对象隐式转换的过程中就是一个调用 ```valueOf``` 和 ```toString``` 的过程，在探讨对象隐式转化为基本类型之前，我们先看看不同类型在调用 ```valueOf``` 和 ```toString``` 的返回结果如何：

1. 不同对象在显示使用 ```toString``` 的返回情况：
    ```
    ({a:1}).toString();  //[object Object]
    //这里调用的是Object.prototype上的toString方法，
    ```
    ```
    [1,2,3,4].toString(); 
    //"1,2,3,4", 返回一个将每个元素拼接在一起以逗号相隔的字符串
    //调用的是Array.prototype上的toString方法，
    ```
    ```
    (function fn(){ console.log("I am a function !");}).toString();
    //'function fn(){ console.log("I am a function !");}'
    // 调用的是Function.prototype上的toString方法
    ```

    ```
    (new Date(2019, 0, 1)).toString(); 
    //"Tue Jan 01 2019 00:00:00 GMT+0800 (中国标准时间)" 返回一个时间和日期的字符串。
    //调用的是Date.prototype上的toString方法，

    ```

    ```
    (/\d/).toString(); 
    // "/\d/" 正则表达式的直接变量的字符串
    // 调用的是RegExp.prototype上的toString方法，

    ```

    
2. 不同对象在显示使用 ```valueOf``` 的返回情况：
    ```
    ({a:1}).valueOf();
    [1,2,3,4].valueOf();
    (function fn(){ console.log("I am a function !");}).valueOf();
    (new Date(2019, 0, 1)).valueOf(); 
    (/\d/).valueOf(); 
    ```
    除了日期对象返回的是一个表达传入日期的毫秒数，<b>其他的都是返回对象本身</b>。只有```Date.prototype``` 上有 ```valueOf``` 方法，对于 ```Array```, ```RegExp```, ```Function```类型，如果没有在实例上或者 ```prototype``` 上手动添加 ```valueOf``` 方法， 则都调用继承自 ```Object.prototype``` 上的 ```valueOf``` 方法。

    在使用```+```，```==```，```!=```和比较运算符时，运算符的一边是对象，一边是基本类型数据，这是对象就会发生数据类型转换，转换基本类型再做运算。

#### 对象转化字符串或数字规则：

首先对其调用 ```ToPrimitive``` 抽象操作(调用 valueOf 或者 toString 方法)，该抽象操作再调用 ```[[DefaultValue]]``` (转为基本类型值).


* 在对象到数字的转换:
    1. 如果对象具有 ```valueOf``` 方法，后者返回一个原始值，则 JavaScript 将这个原始值转换为数字（如果需要的话）并返回这个数字。
    
    2. 否则，如果对象具有 ```toString``` 方法，如果返回一个原始值（如果不是数字）， 则将其转换为数字再返回。
    
    3. ```toString``` 方法不是返回一个原始值，JavaScript抛出一个类型错误异常。

* 对象到字符串的转换:

    1. 如果对象具有 ```toString``` 方法，则调用这个方法。如果它返回一个原始值，
    (如果本身不是字符串的话) JavaScript 将这个值转换为字符串，并返回这个字符串结 
    果。
    
    2. 如果对象没有 ```toString``` 方法，或者这个方法并不返回一个原始值，那么
    JavaScript 会调用```valueOf``` 方法。 如果存在这个方法，则JavaScript调用它。如果返 
    回值是原始值，（如果本身不是字符串的话）JavaScript 将这个值转换为字符串， 
    并返回这个字符串结果。
    
    3. 否则，JavaScript 无法从 ```toString``` 或 ```valueOf``` 获得一个原始值，因此这时它将抛 
    出一个类型错误异常。

对象转字符串或者数字，到底先调用了 ```valueOf``` 还是 ```toString``` , 为了方便记忆，可以只记住转字符串是先调用``` toString```，用 ```"String"``` 关键字来记忆。转数字的方式和转字符串相反就对了。


在使用 ```+```，```==```， ```!=```和比较运算符时，如果 ```+``` 一边是对象，JavaScript 将使用特殊的方法将对象转换为原始值。对于非日期的对象，对象到原始值的转换基本是对象到数字的转换（首先调用 ```valueOf()``` ）; 日期对象则使用对象到字符串的转换模式。日期对象的 ```valueOf``` 或者 ```toString``` 返回的原始值将被直接使用，而不会强制转换为数字或者字符串。（可能是因为 ```Date.prototype``` 中含有 ```valueOf``` 方法，执行 ```Date``` 对象的 ```valueOf``` 方法，返回一个表示毫秒米数字，而其它对象执行的 ```valueOf``` 方法继承自 ```Object.prototype``` 上。且返回的对象本身）

> 验证：为了方便验证，在对象的实例上添加```valueOf```，```toString``` 方法来覆盖原型上的。

```
var arr = [1,2];
arr.valueOf = () => "valueOf";
arr.toString = () => "toString";
arr + 1; // "valueOf1"  
arr + "a"; // "valueOfa"
// 运算符一边除了对象，不管是字符串还是数字，都是调用了valueOf方法
```
这一段代码就是文章开头的其中一段，数组是一个对象，当它和基本类型值相加的时候就会先进行隐式强制类型转换，采用的是对象向数字转换的规则，先调用对象的valueOf 方法， 这个我们为了更好的说明，自定义了一个valueOf覆盖了Object原型上的valueOf。 valueOf返回了"valueOf",这是一个基本类型值，所以到这儿隐式类型转换就完成了。然后进行字符串相加得到"valueOf1"


```
var date = new Date();
date .valueOf = () => "valueOf ";
date .toString = () => "toString";
date + 1;  //"toString1"
date + "a";  //"toStringa"

// 对于Date对象，不管运算符的一边是字符串还是数字，都是调用了 toString
```

```
var arr = [1,2];

arr + 1; // "1,21"
arr + "a"; //"1,2a"

arr.toString()  + 1; // "1,21"
```

```arr + 1``` 这里是并不是直接调用了 ```toString```,而是先调用 ```valueOf``` 得到 ```[1,2]```, 再调用 ```toString``` 得到字符串结果。


### == 和 ===

宽松相等（loose equals）== 和严格相等（strict equals）=== 都用来判断两个值是否“相等”，但是它们之间有一个很重要的区别：<b> == 允许在相等比较中进行强制类型转换，而 === 不允许</b>。

“== 检查值是否相等，=== 检查值和类型是否相等” 的说法是错的，== 和=== 都会检查操作数的类型。区别在于操作数类型不同时它们的处理方
式不同。<b>```==``` 会进行隐式强制类型转换，而 ```===``` 不会</b>。

到底是用 ```==``` 还是 ```===```，如果两个值的类型不同，我们就考虑有没有强制类型转换的必要，有就用 ```==```，没有就用 ```===```。


1. 字符串和数字之间的相等比较
```==``` 的两个操作数中如果一个是字符串，一个是数字，不管字符串是在左边还是右边，都是字符串转化为数字。

```
"42" == 2; // ---> 42 == 2
2 == "42"; // ---> 2 == 42
```

2. 其他类型和布尔类型之间的相等比较
== 的两个操作数中有一个是布尔值，不管布尔值是在左边还是右边，都是布尔值先转化为数字。
```
true == "42"; // 1 == "42"
0 == false; // 0 == 0
```

<b>*</b> 其实使用 ```==``` 判断布尔值和其他数值是否相等 的用途并不大，特别谨慎在if()等这样的判断语句使用。 根据一个值是否等于一个布尔值来判断这个值的真假是不严谨的。

例如 ```if( 2 == true )```， 其实 2 为一个真值，但是这个判断并不会通过，不如直接使用```if(2)```


3. ```null``` 和 ```undefined``` 之间的相等比较

null 和 undefined 做 ```==``` 运算，null == undefined 和 undefined == null 都是返回true。 
```
null == undefined; //true
undefined == null  //true
```

null 和 其他的假值相等比较都是返回 false.

```
var n = null, u = undefined;
false == n; //false
false == u; //false
'' == n;    //false
'' == u;    //false
0 == n;     //false
0 == u;     //false
```

所以在实际运用中我们可以通过这种方式将null 和undefined
作为等价值来处理比较好。
```
if(val == null){
    cosnole.log("you are null or undefined")
}

if(val === null || val === undefined){
    cosnole.log("you are null or undefined")
    
}
```
在这里只有 null 和 undefined 可以通过，而其他的假值是不能通过的，真值一样不能。用于判断 null 和 undefined，方式一对于方式二要简洁很多。


4. 对象和非对象之间的相等比较
关于对象和基本类型（字符串/ 数字/ 布尔值）之间的相等比较,不管对象是在左边还是右边，都是对象转化为基本类型，采用的 ToPrimitive 方式是对象转数字的规则。但是如果基本类型的值是布尔值，就先采用 ```其他类型和布尔类型之间的相等比较```的规则，将布尔值先转换成数字。

我们看看一个例子：
```
var obj = {
    valueOf:() => 1
}
console.log(true == obj);
```
布尔值进行转换得到1，对象进行转换得到1，所以打印出来的是 true。



#### 不要轻易重写覆盖原型上的方法
```
var i = 2;
Number.prototype.valueOf = function() {
    return i++;
};

var a = new Number( 42 );
if (a == 2 && a == 3) {
    console.log( "Yep, this happened." );
}
```
//待完善

#### <= 和 >=
```
var a = { b: 42 };
var b = { b: 43 };
a < b; // false
a == b; // false
a > b; // false

a <= b; // true
a >= b; // true
```

前三面个比较比好理解，a,b 向数字转换，最后的比较是 NaN 的比较，所以三个都是返回的 false。

但是 <= 和 >= 返回了true，NaN 和 NaN 既不是大小于的关系，也不是相等的关系。原因在 JavaScript 中，
 <= 是 “不大于” 的意思, 即 a <=b 为 !(a > b)， a >= b 处理为 !(b < a)。
 
 
 总结：
 
1. && 和 || 运算符的返回值并不一定是布尔类型，而是两个操作数其中一个的值。
2. 对象转换为原始值：转换为布尔值，所有的对象转换为布尔值时都为true；转换为字符串和转换为数字时，有两种转换方法toString()和valueOf()，在不同的场景会使用不同的方法。
3. 在使用 +，==， !=和比较运算符时，如果 + 一边是非日期的对象，采取的是对象到数字的转换。日期对象的 valueOf 或者 toString 返回的原始值将被直接使用，而不会强制转换为数字或者字符串。
4. == 会进行隐式强制类型转换，而 === 不会
5. 字符串和数字之间的相等比较，都是字符串转化为数字。
6. 其他类型和布尔类型之间的相等比较，都是布尔值先转化为数字。
7. 除了undefined，null 和 其他的假值相等比较都是返回 false。
8. 不要轻易重写覆盖原型上的方法
9. 在JavaScript 中， <= 是“不大于”的意思, 即 a <=b 为 !(a > b)， a >= b 处理为 !(b < a)。