服务器配置的优化

文件的优化(图片，CSS，JS)

如何放置CSS，JS文件

代码的优化

用户体验的优化



#### 使用 HTTP / 2.0
* 在 HTTP / 1.1 时代，每个请求都需要建立和断开，消耗了好几个 RTT （客户到服务器往返所花时间，round-trip time）时间，并且由于 TCP 慢启动的原因，加载体积大的文件会需要更多的时间。

* 在 HTTP / 2.0 中引入了多路复用，能够让多个请求使用同一个 TCP 链接，极大的加快了网页的加载速度。并且还支持 Header 压缩，进一步的减少了请求的数据大小。

#### prebrowsing

1. ```dns-prefetch```： DNS 预解析，告诉浏览器未来我们可能从某个特定的 URL 获取资源，当浏览器真正使用到该域中的某个资源时就可以尽快地完成 DNS 解析。多在使用第三方资源时使用。

2. ```preconnect```：预连接(DNS, TCP, 传输)，完成 DNS 预解析同时还将进行 TCP 握手和建立传输层协议。

3. ```prefetch```：预获取(下个页面的资源)，在浏览器空闲的时候提前加载资源并缓存。如果某个资源的 preFetch 还没有完成页面就要使用，这个时候会再次发送请求。因此<b>不要在当前页面中的资源使用 prefetch </b>
    ```<link href="main.js" rel="prefetch">```

4. ```prerender```：预渲染(下个页面的资源)，预先加载文档的所有资源，类似于在一个隐藏的 tab 页中打开了某个链接 – 将下载所有资源、创建 DOM 结构、完成页面布局、应用 CSS 样式和执行 JavaScript 脚本等。

5. ```preload```：预加载，主动通知浏览器获取本页的关键资源，只是预加载，加载资源后并不会执行；

prefetch & preload：前面三种不少浏览器已经内部默认做了优化，而prefetch & preload需要开发者根据情况代码手动设置。

#### 优化实践
1. HTML文件

虽然大多数html只会在每次发布上线时才会改变，如更新js/css资源的引用地址，所以一般将HTTP Headers中设置一个比较短的max-age值，如cache-control: max-age=300，除此之外建议服务器开启Etag。

但以实时内容为主的网站（如金融类）为了页面的打开速度，会采取后台服务生产的方式 ，将所有首页数据全部生成到html中，省去用户首次加载时的后台接口请求等待时间。一般会设置cache-control: no-cache。

2. js/css/img文件

现在一般都通过文件名进行版本控制。Webpack打包命名可根据文件内容生成文件名的hash值，每次打包只有当内容改才重新生成hash值。此种情况之下，可以在HTTP Headers设置一个较大的缓存时间，如max-age=2592000，尽量避免304请求和服务器进行请求连接。
```
// js
output: {
    path: config.build.assetsRoot,
    filename: utils.assetsPath('js/[name].[chunkhash].js'),
    chunkFilename: utils.assetsPath('js/[id].[chunkhash].js'),
}
// css
new ExtractTextPlugin({
    filename: utils.assetsPath('css/[name].[contenthash].css'),
})
```

3. webfont

webfont文件比较特殊，正如这篇文章中所说：

浏览器在DOMNode的CSS选择器中发现@font-face时才会下载web fonts文件，这个时候浏览器已经下载完成html/css/js文件；
如果在浏览器发现需要加载font文件之前就告诉浏览器下载font文件，会加快文件下载和页面加载速度。
其实不同浏览器下载font文件的时间不太一样，有的碰到css的声明就会加载，有的会等到dom节点匹配css声明时加载。


------------------------------------------------------------------------------

------------------------------------------------------------------------------
## 文件优化

#### 图片优化
##### 压缩图片大小
一张 100*100 像素的图片，图像上有 10000 个像素点，如果每个像素的值是 RGBA 存储的话，那么也就每个像素有 4 个通道，每个通道 1 个字节（8 位 = 1 个字节），所以该图片大小大概为 39KB（10000 _ 1 * 4 / 1024）。

但是在实际项目中，一张图片可能并不需要使用那么多颜色去显示，我们可以通过减少每个像素的调色板来相应缩小图片的大小。

优化图片思路：

1. 减少像素点
2. 减少每个像素点能够显示的颜色

##### 图片加载优化

1. 尽量用 CSS 代替图片。
2. 将图片存放在 CDN 上。
3. 移动端根据适配宽度请求相应裁剪好的照片
4. 小图片转base64，放在代码中(如果转换的代码过多也会导致文件臃肿)。
5. 能用SVG 代替的图片用SVG。
6. 尽量使用 WebP 格式。WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积
7. 将多个图标文件整合到一张图片中（雪碧图）

##### 其他文件优化
1. CSS 文件放在 head 中
2. 服务端开启文件压缩功能
3. 
- 将 script 标签放在 body 底部，因为 JS 文件执行会阻塞渲染；

- 添加 defer ，表示该文件会并行下载，但是会放到 HTML 解析完成后顺序执行。
        
- 对于没有任何依赖的 JS 文件可以加上 async ，表示加载和渲染后续文档元素的过程将和 JS 文件的加载与执行并行无序进行。
4. 费时的代码可以考虑使用 Webworker。Webworker 可以让我们另开一个线程执行脚本而不影响渲染。

##### CDN
静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie。

#### 其他
##### 使用 Webpack 优化项目
对于 Webpack4，打包项目使用 production 模式，这样会自动开启代码压缩
使用 ES6 模块来开启 tree shaking，这个技术可以移除没有使用的代码
优化图片，对于小图可以使用 base64 的方式写入文件中
按照路由拆分代码，实现按需加载
给打包出来的文件名添加哈希，实现浏览器缓存文件
##### 监控
使用 window.onerror 拦截报错。该方法能拦截到大部分的详细报错信息，但是可能也有例外

- 对于跨域的代码运行错误会显示 Script error. 对于这种情况我们需要给 script 标签添加 crossorigin 属性
- 对于某些浏览器可能不会显示调用栈信息，这种情况可以通过 arguments.callee.caller 来做栈递归

对于异步代码来说，可以使用 catch 的方式捕获错误。比如 Promise 可以直接使用 catch 函数，async await 可以使用 try catch

线上运行的代码都是压缩过的，需要在打包时生成 sourceMap 文件便于 debug。

对于捕获的错误需要上传给服务器，通常可以通过 img 标签的 src 发起一个请求。

## 代码相关

1. 在实现动画的时候使用 translate 替代 top。
```
<div class="test"></div>
<style>
  .test {
    position: absolute;
    top: 10px;
    width: 100px;
    height: 100px;
    background: red;
  }
</style>
<script>
  setTimeout(() => {
    // 引起回流
    document.querySelector('.test').style.top = '100px'
  }, 1000)
</script>
```
2. 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）

3. CSS 选择符从右往左匹配查找，避免 DOM 深度过深

4. 一下复杂的动画可以使用GUP加速。

5. 把 DOM 离线后修改，将所有的DOM修改完成后再添加到文档中。比如：先把 DOM 给 display:none (有一次 Reflow)，然后你修改 100 次，然后再把它显示出来

6. 不要把 DOM 结点的属性值放在一个循环里当成循环里的变量

```
for (let i = 0; i < 1000; i++) {
  // 获取 offsetTop 会导致回流，因为需要去获取正确的值
  console.log(document.querySelector('.test').style.offsetTop)
}
```

7. 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局

8. 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame




## 面试题
如何渲染几万条数据并不卡住界面





