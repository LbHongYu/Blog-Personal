#### 定时器


> #### setInterval

setInterval指定的是 “开始执行” 之间的间隔，并不考虑每次任务执行本身所消耗的时间。因此，两次执行之间的间隔（指定时间-执行时间）会小于指定的时间。比如，setInterval指定每 100ms 执行一次，每次执行需要 5ms，那么第一次执行结束后95毫秒，第二次执行就会开始。如果某次执行耗时特别长，比如需要105毫秒，那么它结束后，下一次执行就会立即开始。然后会有越来越多的任务堆积在事件队列中。

setInterval(function(){
	console.count();

	var start = Date.now();
	while(Date.now() - start < 2000){					
	}
	console.log("finish waiting");
}, 2000);		

//打印了"finish waiting" 就会马上进入下一个执行。

为了确保两次执行之间有固定的间隔，可以使用setTimeout 代替 setInterval。
var i = 1;
var timer = setTimeout(function f() {
  // ...
  timer = setTimeout(f, 2000);
}, 2000);

#### 开始执行时间
setTimeout和setInterval指定的回调函数，必须等到本轮事件循环的所有同步任务都执行完，才会开始执行。由于前面的任务到底需要多少时间执行完，是不确定的，所以没有办法保证，setTimeout和setInterval指定的任务，一定会按照预定时间执行。

```
console.log("start");
setInterval(function () {
	//生效后setInterval不会产生累积效应，即不会一下子输出三个 "interval"，而是只会输出一个 "interval"。
	
  console.log("interval");
}, 1000);

sleep(3000);

//等待三秒

function sleep(ms) {
  var start = Date.now();
  while ((Date.now() - start) < ms) {
  }
}
```

```
console.log("start");
console.time("waiting time");

setTimeout(function(){
	console.log("start timer");
	console.timeEnd("waiting time");
}, 100);
sleep(3000);
```

#### setTimeout(f, 0)

这种写法的目的是，尽可能早地执行f，但是并不能保证立刻就执行f。 除去主线程的执行时间，在不同浏览器中，它的最小等待时间在4-16 之间。