## 当JS引擎遇到 var a = 2 发生了些什么？

在阐述结果之前先说明几个概念。

#### 引擎的工作过程：
- 编译器首先会将这段程序分解成词法单元 —— 分词/词法分• 析（Tokenizing/Lexing）

- 将词法单元解析成一个树结构 —— 解析/语法分析（Parsing）

- 编译器会在当前作用域声明一个变量a（如果有同名称变量存在于同一个作用域的集合中，则忽略这个变量），为引擎生成运行时所需要的代码，这些代码被用来处理a = 2这个赋值操作。

- 引擎会在作用域中查找该变量，如果能够找到就会对它赋值（如果能在当前作用域找到就直接使用这个变量，如果不能，继续向向上一级作用域查找，直到全局作用域）。


##### LHS, RHS
介绍两个概念：LHS, RHS，当变量出现在赋值操作的左侧时进行LHS 查询，将RHS 理解成retrieve his source value（取到它的源值），这意味着“得到某某的值”。

上示例：

```
function foo(a) {
    //1、
    //对a 的引用是一个RHS 引用，因为这里a 并没有赋予任何值。
    console.log( a ); // 2
}

//2、
// 2被当作参数传递给foo(..) 函数时，2 会被分配给参数a。
// 为了给参数a（隐式地）分配值，需要进行一次LHS 查询。

//3、
//foo(..) 函数的调用需要对foo 进行RHS 引用，意味着“去找到foo 的值"
foo( 2 );
```
在这段代码中就既有LHS也有RHS。

#### 作用域嵌套
当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用
域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，
或抵达最外层的作用域（也就是全局作用域）为止。


```
function foo(a) {
console.log( a + b );
}
var b = 2;
foo( 2 ); // 4
```

对b 进行的RHS 引用无法在函数foo 内部完成，但可以在上一级作用域（在这个例子中就
是全局作用域）中完成。

#### 综合作用域嵌套和引擎的工作原理简述一下LHS和RHS的过程：

JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像var a = 2 这样的声
明会被分解成两个独立的步骤：

1. 首先，在代码执行前进行，如果其作用域中还未存在变量a ，var a就会 在其作用域中声明新变量。
2. 接下来，a = 2 会查询（LHS 查询）变量a 并对其进行赋值。

LHS 和RHS 查询都会在当前执行作用域中开始，查找所
需的标识符，如果没有找到就会向上级作用域继续查找目标标识符，直至最后抵达全局作用域（顶层），无论找到或没找到都将停止。
不成功的RHS 引用会导致抛出ReferenceError 异常。不成功的LHS 引用会导致自动隐式
地创建一个全局变量（非严格模式下），该变量使用LHS 引用的目标作为标识符，或者抛
出ReferenceError 异常（严格模式下）。