
## V8 的性能优化策略

V8 是 Google 团队开发的一个 JavaScript 开源引擎，Chrome 浏览器在2008年发布，经过起起伏伏，最终在2012年超越IE，在全球的浏览器市场占有率第一。本文我们一起来探索 V8 是如何提升性能的。我们将围绕 V8 执行 JavaScript 代码的过程，选取几个优化策略进行学习了解。

### 一、JIT (Just In Time)
首先我们先来了解一下 V8 是如何执行 JavaScript 代码的？V8 采用的是JIT (Just In Time)的执行方式，这是一种结合"解析执行"和"编译执行"的混合执行方式。解析执行具有快速执行、内存优化的特点，编译执行具有高性能执行的特点，JIT 则结合它们的特点。下面简单介绍一下 V8 执行一段代码所经历的主要流程。

#### 1. 初始化基础环境
在 V8 启动执行 JS 之前，它还需要准备执行 JS 时所需要的一些基础环境：
  * 全局执行上下文
  * 全局作用域
  * 堆、栈
  * 消息循环系统：消息驱动器，消息队列

执行上下文的周期，分为两个阶段：<b>创建阶段</b>，<b>执行阶段</b>

创建阶段
  * 创建词法环境
  * 生成变量对象(VO)，建立作用域链、作用域链、作用域链（重要的事说三遍）
  * 创建 arguments 对象
  * 在函数体里找到函数声明，值赋予函数体，当遇到同名的函数时，后面的会覆盖前面的
  * 检查当前环境中的变量声明并赋值为undefined。当遇到同名的函数声明，为了避免函数被赋值为 undefined ,会忽略此声明
  * 确认this指向，并绑定this

执行阶段

  * 进行变量赋值，函数引用及执行代码
  * 变量对象变为活动对象

#### 2. Parser 解析 JS 代码，生成 AST 和作用域，Ignition[ɪɡˈnɪʃn]  根据AST和作用域生成字节码。

JS 代码对 V8 来说只是一堆字符串，并不能理解它的含义，需要将其结构化——生成抽象的语法树AST，AST 是便于 V8 理解的结构。

在生成AST的同时V8还会生成相关的作用域，作用域中存放相关变量信息（这个时候变量都还是undefined，没有被赋值）。

根据AST和作用域生成字节码，字节码是介于AST和机器代码（针对不同的CPU架构编写特定的代码）的中间代码，但是它与特定类型的机器代码无关。浏览器解释器可以直接解释执行字节码，

#### 3. 执行字节码
按照顺序执行字节码，并输出执行结果。

#### 4. 监听热点代码
将重复执行的字节码标记为热点代码

#### 5. TurboFan ['tɜːrbo,fæn]: 优化热点代码为二进制的机器代码
TurboFan 在后台将热点代码编译为优化代码，下次再执行这段代码，V8会优先选择优化代码，这样代码的执行速度会大幅提升。

#### 6. 反优化机器代码
优化的代码被修改了，就需要执行反优化操作。经过反优化的代码下次执行就会回退到 Ignition 解释执行

![JIT.jpg](../image/杂谈/JIT.jpg "JIT")

### 二、代码执行后的代码缓存
从 V8 v6.6 (Chrome 66) 开始，引擎在顶层执行后，会把生成的更多代码缓存起来。这会让初始加载时的分析和编译时间缩短 20-40%。

cold run: 当JS文件第一次被请求时(即 cold run)，Chrome 会下载它并将其提供给V8编译。它还将文件存储在浏览器的磁盘缓存中。

warm run: 当JS文件第二次被请求时(即 warm run)，Chrome 从浏览器缓存中获取该文件，并再次将其提供给 V8 编译。但是，这一次，编译后的代码被序列化，并作为元数据附加到缓存的脚本文件中。

hot run: 第三次(即 hot run)，Chrome从缓存中获取文件和文件的元数据，并将它们交给V8。V8反序列化元数据，可以跳过编译

PS: V8 使用两种代码缓存策略来缓存生成的代码，以便以后重用。

1. 存在于每个 V8 实例中的内存缓存（in-memory cache）。初始编译后生成的代码存储在此缓存中，以源字符串作为 key。这可以在 V8 的相同实例中重复使用。
2. 代码缓存序列化生成的代码并将其存储在磁盘上供将来使用。该缓存并不只属于 V8 的特定实例，可以在 V8 的不同实例中使用。

![hot-run.jpg](../image/杂谈/hot-run.jpg "hot-run")

### 三、延迟解析
V8执行JS代码需要经过编译和执行两个阶段，在编辑阶段，JS代码转换为字节码或者二进制代码，执行阶段解释器解释执行字节码，或者CPU直接执行二进制代码。

在编译过程中，V8并不会将所有的代码解析为中间代码（字节码或二进制代码），所有主流的JS虚拟机都实现了惰性解析 —— 解析器在解析的过程中，如果遇到函数声明，会跳过函数内部的代码，并不会为其生成AST 和字节码，只生成这一层的AST和字节码。

这样做的原因是解析和编译所有的代码会增加编译时间，会影响首次执行代码的时间；中间代码会存放在内存中，一次性解析和编译所有的代码，一些中间代码会一直占用内存。

```
// 1. 遇到 foo 函数, 将函数转换为函数对象。（没有解析和编译函数内部的代码）
function foo (a, b) {
  var d = 1;
  var f = 1;
    return d + f +  a + b;
}

// 2. 生成AST 和 中间代码。
var global_a = 1;
var global_b = 1;

// 从 foo 函数对象中取出函数代码，编译，执行
foo(global_a, global_b);
```

### 四、隐藏类(模拟静态语言通过偏移量来查询对象的属性)

在静态语言中的在执行过程是对象无法修改的，在编译的时候会将对象属性的地址写进汇编指令，在访问对象的属性时，就可以直接去内存中取出该内容即可。

通过偏移量来查询对象属性的方式也是静态语言执行效率高的一个原因。
这个特性是否利用在JS中呢？答案是可以的。

对象创建好了之后就不会添加新的属性，且不会删除属性。V8 就可以对对象做深度优化，为每一个对象建立一个隐藏类，隐藏类记录对象中所有的属性的属性值在内存中相对于对象的偏移。

当访问某个对象的某个属性，就会先在隐藏类中查找该属性相对于与它所在变量的偏移量，有了偏移量和属性，就可以直接从内存中取出对应的属性值。

这就是 V8 将动态语言静态化的一个操作，引入隐藏类，模拟C++这种静态语言的机制，从而达到静态语言的执行效率。

隐藏类描述了对象属性的布局，主要包含了属性名及其对应的偏移量。例如对象`point`, `let point = { x: 100, y: 200 };` point 对象的隐藏类就包括了 x 和 y 属性，偏移量分别为 4 和 8.

![隐藏类.jpg](../image/杂谈/隐藏类.jpg "隐藏类")

多个对象共用一个隐藏类：在V8中每个对象都有一个map属性，该属性指向对象的隐藏类，如果两个对象属性名称和个数都相同，V8 将会复用同一个隐藏类。这样可以减少隐藏类的创建次数，间接加速了代码执行速度，减少了隐藏类的存储空间。

重新构造隐藏类：前面提到了实现隐藏类的假设条件：对象创建好了之后就不会添加新的属性，且不会删除属性。如果这两个条件任意一个被破坏（添加数组索引属性不会创建新的隐藏类），V8 就要为新的对象构建新的隐藏类，每添加新的命名属性都会导致一个新的隐藏类被创建。

![修改隐藏类.jpg](../image/杂谈/修改隐藏类.jpg "修改隐藏类")

### 五、对象内属性、快属性和慢属性
JavaScript 对象像一个字典，字符串作为键名，任意对象可以作为键值，通过键名读写键值。
然而在V8实现对象存储时，并没有完全采用字典的存储方式。
因为字典是非线性的数据结构，查询效率会低于线性的数据结构，V8 为了提升存储和查找效率采用了一套复杂的存储策略。
看一段代码：
```
var obj = {
  b: 'b',
  100: 100,
  5: 5,
  3: 3,
  a: 'a',
  1: 1
};
for (let i in obj) {
  console.log(i, obj[i]);
}
// 顺序打印：
// 1 1
// 3 3
// 5 5
// 100 100
// a a
// b b
```
打印的顺序并不是属性在obj里的顺序，因为 ECMAScript 规范中定义了<b>数字（数字字符串会转换为数字）属性应该按照索引值大小升序，字符串属性根据创建的顺序排列</b>。

对象中的数字属性被称为排序属性(elements)，字符串属性被称为常规属性(properties)。为了提升存储和访问这两种属性的性能，V8 使用了两个线性数据结构来分别保存这两种属性。

![elements-properties.jpg](../image/杂谈/elements-properties.jpg "elements-properties")


将不同的属性保存到 `elements` 和 `properties` 属性中，虽然简化了程序的复杂度，但是在查找元素时却多了一步操作，因此会影响到元素的查找效率。基于这个原因，V8采取了一个权衡的策略以加快查找属性的效率。将部分常规的属性直接存储到对象本身，我们把这称为对象内属性(in-object properties).

采用对象内属性之后，读取 `a` 属性就可以直接从对象本身去获取该值，这种方式减少了查找步骤，提高了查找效率。<b>对象内属性的数量是固定的，默认是 10 个</b>，超出的就会被保存在“快属性”和“慢属性”中。快属性为线性数据结构，<b>慢属性的对象内部为非线性数据结构（词典）</b>。慢属性的属性元信息不再是线性存储的而是直接保存在属性字典中。

### 六、内联缓存
先看一段代码：
```
function loadX () {
    return o.x;
}
var o = { x: 1, y: 3 };
var o1 = { x: 3, y: 6 };
for (var i = 0; i < 10000; i++) {
    loadX(o);
  loadX(o1);
}
```
获取o.x的流程为：查找对象 o 的隐藏类，通过隐藏类查找属性x的偏移量，然后通过偏移量（相对对象o的）获取属性值。这里经过三个步骤，在for循环中反复执行了loadX函数去获取 o.x，是否有办法去简化获取过程？这个时候就该内联缓存（Inline Cache）登场了。

V8 在执行函数的过程会观察一些调用点上的关键“中间数据”，然后将这些数据缓存起来。下次再执行该函数的时候，V8就可以直接利用这些“中间数据”，以此节约再次获取这些数据的过程。IC 会为每个函数维护一个反馈向量(FeedBack Vector)，它记录了函数在执行过程中的一些关键数据。

![反馈向量.jpg](../image/杂谈/反馈向量.jpg "反馈向量")

反馈向量是一个表结构，表结构的每一个行称为一个插槽(Slot)，每个插槽包括插槽的索引、插槽的类型(type)、插槽的状态(state)、隐藏类(map)的地址和属性偏移量(offset)。

插槽的类型有访问类型(LOAD)，存储类型(STORE)，函数调用类型(CALL)。

![插槽.jpg](../image/杂谈/插槽.jpg "插槽")

```
StackCheck
LdaNamedProperty a0, [0], [0]
return
```
这三行字节码表示：
  1. 检查栈是否溢出
  2. 取出参数a0 的第一属性值，并将属性值当道累加器中。
  a0 表示loadX的第一个参数，
  第一个 [0] 表示取出对象a0的第一个属性值
  第二个[0] 将LdaNamedProperty操作的中间数据写入到反馈向量中，其中'0' 表示写入反馈向量的第一个插槽中。
  3. 返回累加器中的属性值

现在loadX函数的反馈向量就是这个样子：

![反馈向量-2.jpg](../image/杂谈/反馈向量-2.jpg "反馈向量-2")

当再次调用loadX 函数时，执行laodX函数中的语句时，他就会在对应的插槽中查找对应的偏移量，然后就可以直接在内存中获取执行结果了。

多态和超态：
在文章开始的那段代码中，有两个对象，意味着会创建两个隐藏类。在 for 循环中执行了两次loadX函数分别读取这两个对象的 x 属性， 第一次执行时，loadX函数的反馈向量会存储o.x 的偏移量。再执行loadX，读取o1.x时，会取出反馈向量中的记录的隐藏类和o1进行比较，发现不是同一个隐藏类，不能使用。于是新的隐藏类也被记录到同一个插槽中。

当在函数执行一个已经执行过的属性读取语句 (return o.x)，V8 会将这个要被访问的对象的隐藏类和插槽中的隐藏类对比，如果找到同样的隐藏类，就会使用这个隐藏类，如果没有找到，就在同一个插槽添加一个新的隐藏类。
![多态.jpg](../image/杂谈/多态.jpg "多态")

  * 单态：1个隐藏类，
  * 多态：包含了 2～4 个，
  * 超态：超过4个。

单态和多态会使用的线性结构来存储，超态会使用 hash 表储存，单态，多态，超态，(隐藏类)访问复杂度依次增大，执行效率依次减弱。所以建议使用单独的函数读取不同对象的属性，这样就会为不同的函数创建不同的反馈向量。

### 总结
本文从“代码执行后的代码缓存”，“内联缓存”，“延迟解析”，“隐藏类”，“对象内属性、快属性和慢属性”等5个点来探究V8 是如何来做优化的。

* “代码执行后的代码缓存” 优化执行多次加载的代码，缓存其顶层作用域的字节码。
* “内联缓存” 使用反馈向量保存函数里的每条语句的执行结果，当再次执行时会直接在反馈向量中取出缓存结果。
* “延迟解析” 为了尽快执行代码，最先只会解析“顶层”代码。
* “隐藏类” 使JavaScript在读取对象中属性时拥有接近静态语言的性能。
* “对象内属性、快属性和慢属性” 提高了对象属性的查找效率。

感谢你的阅读，才疏学浅，若有错误，欢迎指出～

参考链接：

https://v8.js.cn/blog/blinkon-6/

https://v8.js.cn/blog/improved-code-caching/

https://v8.js.cn/blog/code-caching-for-devs/

https://v8.js.cn/blog/fast-properties/

《极客时间-图解V8》